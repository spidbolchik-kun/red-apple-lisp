(define (boolean? value) (##boolean? value))

(define (procedure? value)
  (or (ra::procedure? value) (##procedure? value)))

(define (number? value) (##number? value))
(define (integer? value) (##integer? value))
(define (string? value) (##string? value))
(define (list? value) (##list? value))
(define (kv? value) (ra::dictionary? value))
(define (not value) (##not value))
(define (nil? value) (##equal? value (##void)))
(define nil (##void))

(define (const value) (fn (& args #key & rest) value))
(define (identity value) value)


(define (empty? value)
  (assert (or (list? value) (kv? value)))
  (if (list? value)
    (##null? value)
    (ra::dictionary-empty? value)))


(define (kv-set key to in)
  (assert (kv? in))
  (ra::dictionary-set in key to))


(define (push value to)
  (assert (list? to))
  (##cons value to))


(define (push-back value list)
  (assert (list? list))
  (if (empty? list)
    [value]
    (push (head list) (push-back $list: tail))))


(define (head list)
  (assert (list? list))
  (##car list))


(define (first list)
  (assert (list? list))
  (##car list))


(define (second list) (first (tail list)))


(define (tail list)
  (assert (list? list) (not (empty? list)))
  (##cdr list))


(define (last list)
  (assert (list? list) (not (empty? list)))
  (if (empty? (tail list))
    (head list)
    (last (tail list))))


(define (but-last list)
  (assert (list? list))
  (if (or (empty? list) (empty? (tail list)))
    list
    (push (head list) (but-last (tail list)))))


(define (all? predicate of = [head & tail])
  (if (empty? of)
    #t
    (and (predicate head) (all? of: tail))))


(define (any? predicate of = [head & tail])
  (if (empty? of)
    #f
    (or (predicate head) (any? of: tail))))


(define (all-are-either? predicates = [h & t] of)
  (assert (list? predicates) (list? of))
  (if (empty? of)
    #t
    (if (empty? predicates)
      #f
      (or (all? h of) (all-are-either? t of)))))


(define (fold-right with-fn over #key with-final-value)
  (define (fold-right with-fn over with-final-value)
    (if (empty? over)
      with-final-value
      (with-fn (head over) (fold-right $over: tail))))

  (assert (list? over))
  (if (nil? with-final-value)
    (let (assert (not (empty? over)))
      (fold-right with-fn (but-last over) (last over)))
    (fold-right with-fn over with-final-value)))


(define (all-sequential-values? are in = [first & rest = [second]])
  (or (empty? rest)
      (and (are first second) (all-sequential-values? in: rest))))


(define list:==
  (all-sequential-values? are: (fn (x y) (##equal? x y))))


(define (list:!= args) (not (list:== args)))


(define list:+
  (let add2 = (fn (x y) (assert (number? x) (number? y)) (##+ x y))
    (fold-right add2 with-final-value: 0)))


(define list:*
  (let mul2 = (fn (x y) (assert (number? x) (number? y)) (##* x y))
    (fold-right mul2 with-final-value: 1)))


(define (+ x y & rest) (list:+ [x y & rest]))


(define (* x y & rest) (list:* [x y & rest]))


(define (== x y & rest) (list:== [x y & rest]))


(define (!= x y & rest) (list:!= [x y & rest]))


(define (length list)
  (assert (list? list))
  (if (empty? list)
    0
    (+ 1 (length (tail list)))))


(define (list:< list)
  (assert (all? number? list))
  (all-sequential-values? (fn (x y) (##< x y)) list))


(define (list:<= list)
  (assert (all? number? list))
  (all-sequential-values? (fn (x y) (##<= x y)) list))


(define (list:> list)
  (assert (all? number? list))
  (all-sequential-values? (fn (x y) (##> x y)) list))


(define (list:>= list)
  (assert (all? number? list))
  (all-sequential-values? (fn (x y) (##>= x y)) list))


(define (< value & rest)
  (if (empty? rest)
    (fn (& rest) (list:< (push-back value rest)))
    (list:< [value & rest])))


(define (<= value & rest)
  (if (empty? rest)
    (fn (& rest) (list:<= (push-back value rest)))
    (list:<= [value & rest])))


(define (> value & rest)
  (if (empty? rest)
    (fn (& rest) (list:> (push-back value rest)))
    (list:> [value & rest])))


(define (>= value & rest)
  (if (empty? rest)
    (fn (& rest) (list:>= (push-back value rest)))
    (list:>= [value & rest])))


(define (reverse list #default acc = [])
  (assert (list? list))
  (if (empty? list)
    acc
    (reverse (tail list) $acc: (push (head list)))))


(define (apply-if bool-or-predicate function to)
  predicate = (if (boolean? bool-or-predicate) (const bool-or-predicate) bool-or-predicate)
  (if (predicate to) (function to) to))


(define (replace-if bool-or-predicate with value)
  (apply-if bool-or-predicate (const with) value))


(define (fold-left with-fn over #key with-initial-value)
  (define (fold-left with-fn over with-initial-value)
    (if (empty? over)
      with-initial-value
      (fold-left with-initial-value: (with-fn with-initial-value (head over)) $over: tail)))

  (assert (list? over))
  (if (nil? with-initial-value)
    (let (assert (not (empty? over)))
      (fold-left with-fn (tail over) (head over)))
    (fold-left with-fn over with-initial-value)))


(define list:-
  (let sub2 = (fn (x y) (assert (number? x) (number? y)) (##- x y))
    (fold-left sub2 with-initial-value: nil)))


(define list:/
  (let div2 = (fn (x y) (assert (number? x) (number? y)) (##/ x y))
    (fold-left div2 with-initial-value: nil)))


(define (- & args #key & {from})
  args* = (apply-if (not (nil? from)) (push from) args)
  (if (>= (length args*) 2)
    (list:- args*)
    (if (not (nil? from))
      (fn (& args) (list:- (push from args)))
      (fn (arg) (list:- (push arg args))))))


(define (/ & args #key & {dividend})
  args* = (apply-if (not (nil? dividend)) (push dividend) args)
  (if (>= (length args*) 2)
    (list:/ args*)
    (if (not (nil? dividend))
      (fn (& args) (list:/ (push dividend args)))
      (fn (arg) (list:/ (push arg args))))))


(define (map with over & over-rest)
  (define (map-one f list = [head & tail])
    (if (empty? list)
      []
      (push (f head) (map-one f tail))))
  lists = (push over over-rest)
  (if (any? empty? lists)
    []
    (push (with & (map-one head lists))
          (map with & (map-one tail lists)))))


(define (filter by over = [head & tail])
  (if (empty? over)
    []
    (apply-if (by head) (push head) (filter over: tail))))


(define (display! & values)
  (map (fn (value) (##display value)) values)
  nil)


(define (print! & values)
  (map (fn (value) (ra::print value)) values)
  nil)


(define (compose left right & rest)
  (fold-left (fn (f0 f1) (fn (arg) (f1 (f0 arg))))
             [left right & rest]
             with-initial-value: nil))


(define (o left right & rest)
  (compose & (reverse [left right & rest])))


(define (modulo & args #key & {dividend})
  (define (modulo-2 dividend divisor)
    (assert (number? dividend) (number? divisor))
    (##modulo dividend divisor))
  args* = (apply-if (not (nil? dividend)) (push dividend) args)
  (assert (> (length args*) 0) (< (length args*) 3))
  (if (== (length args*) 2)
    (modulo-2 & args*)
    (if (nil? dividend)
      (fn (dividend) (modulo-2 dividend (head args*)))
      (fn (divisor) (modulo-2 dividend divisor)))))


(define (item & path) (fn (value) (value & path)))


(define (take n from)
  (if (or (empty? from) (<= n 0))
    from
    (take (- n 1) (tail from))))


(define (drop n from)
  (if (or (empty? from) (<= n 0))
    from
    (drop $n: (- 1) $from: tail)))


(define (take-while condition from-list = [h & t] #key including-edge = #f)
  (if (empty? from-list)
    []
    (if (not (condition h))
      (apply-if including-edge (push h) [])
      (push h (take-while from-list: t)))))


(define (drop-while condition
                    from-list = [h & t]
                    #key including-edge = #f
                    #default acc = [])
  (if (or (empty? from-list) (not (condition h)))
    [& acc & from-list]
    (drop-while from-list: t acc: (if including-edge [h] []))))


(define (pipe value & functions = [h])
  (if (empty? functions)
    value
    (pipe (h value) $functions: tail)))


(define (cont-push value to)
  (fn accumulator
      (to (push value accumulator))))


(define (list:append lists)
  ((fold-right over: lists with-final-value: [])
   (fn ls0 = [h0 & t0] ls1
       (if (empty? ls0)
         ls1
         (push h0 (#rec t0))))))


(define (append left right & rest)
  (list:append [left right & rest]))


(define (one-of? list value)
  (any? (== value) list))


(define (kv-from-list list = [h] #key with-getters = [first second] #default acc = [])
  [key-getter value-getter] = with-getters
  (if (empty? list)
    (make-ra::dictionary acc)
    (kv-from-list $list: tail
                  $acc: (push (##cons (key-getter h) (value-getter h))))))


(define (modify-item item with of)
  (assert (or (kv? of) (list? of)))

  (define (modify-list-item list = [h & t] #default counter = 0)
    (assert (integer? item))
    (if (empty? list)
      []
      (if (== item counter)
        (push (with h) t)
        (push h (modify-list-item t $counter: (+ 1))))))

  (define (modify-kv-item alist = [h & t])
    (if (empty? alist)
      []
      (if (== item (##car h))
        (push (##cons (##car h) (with (##cdr h))) t)
        (push h (modify-kv-item t)))))

  (if (list? of)
    (modify-list-item of)
    (make-ra::dictionary (modify-kv-item (ra::dictionary-alist of)))))


(define (split list = [h & t], at #key keeping-markers = #f, once = #f #default cont = identity)
  (assert (one-of? [#f 'in-left 'in-right] keeping-markers))
  (if (empty? list)
    [(cont [])]
    (if (at h)
      (push (cont (if (== keeping-markers 'in-left) [h] []))
            (apply-if (== keeping-markers 'in-right)
                      (modify-item 0 with: (push h))
                      (if once [list] (split t cont: identity))))
      (split t $cont: (cont-push h)))))


(define (modify-item* item-path with of)
  ((fold-right modify-item item-path with) of))


(define (replace-item item with of)
  (modify-item item (const with) of))


(define (replace-item* item-path with of)
  (modify-item* item-path (const with) of))


(define (partition list = [h & t] #key by = identity #default acc = {})
  (if (empty? list)
    acc
    (let key = (by h)
         new-acc = (apply-if (nil? (acc key)) (kv-set key []) acc)
      (partition t acc: (modify-item key (push-back h) new-acc)))))


(define (sort list #key by = identity)
  (assert (procedure? by) (list? list))
  (##list-sort (ra::procedure-code (fn x y (< (by x) (by y)))) list))


(define (read-file-string! path)
  (assert (string? path))
  (##read-file-string path))
